From 4f95172d70777357a4b90dd356372ae36be3cb07 Mon Sep 17 00:00:00 2001
From: Adrian Muzyka <adrian.muzyka.it@gmail.com>
Date: Wed, 30 Jul 2025 08:26:52 +0200
Subject: [PATCH] RDK-47153: Option to set dump dir and compression per PID

---
 memcr.c             | 309 +++++++++++++++++++++++++++++++++++++++++---
 memcrclient_proto.h |  23 +++-
 2 files changed, 312 insertions(+), 20 deletions(-)

diff --git a/memcr.c b/memcr.c
index 264ffa3..c12ef3c 100644
--- a/memcr.c
+++ b/memcr.c
@@ -118,7 +118,15 @@ struct vm_area {
 	unsigned long flags;
 };
 
-static char *dump_dir;
+struct dump_dir_list {
+	char *dir;
+	struct dump_dir_list *next;
+};
+
+#define MEMCR_DUMPDIR_DEFAULT "/tmp"
+
+static struct dump_dir_list *allowed_dump_dirs;
+static char *dfl_dump_dir = MEMCR_DUMPDIR_DEFAULT;
 static char *parasite_socket_dir;
 static int parasite_socket_gid = -1;
 static int parasite_socket_use_netns;
@@ -150,6 +158,7 @@ static pid_t tids[MAX_THREADS];
 static int nr_threads;
 
 #define SERVICE_MODE_SELECT_TIMEOUT_MS	100
+#define SERVICE_MODE_SOCKET_TIMEOUT_MS	1000
 
 #define MAX_VMAS			(3*4096)
 static struct vm_area vmas[MAX_VMAS];
@@ -206,6 +215,7 @@ static struct {
 	int state;
 	int checkpoint_abort;
 	int checkpoint_cmd_sd;
+	struct service_options options;
 } checkpoint_service_data[CHECKPOINTED_PIDS_LIMIT];
 
 #define SOCKET_INVALID				(-1)
@@ -430,7 +440,7 @@ static void parasite_socket_init(struct sockaddr_un *addr, pid_t pid)
 	}
 }
 
-static void cleanup_pid(pid_t pid)
+static void cleanup_pid(pid_t pid, const char* dump_dir)
 {
 	char path[PATH_MAX];
 
@@ -826,7 +836,15 @@ static int dump_write(int fd, const void *buf, size_t count)
 	return ret;
 }
 
-static void init_pid_checkpoint_data(pid_t pid)
+static void clear_checkpoint_options(struct service_options *options)
+{
+	options->is_dump_dir = FALSE;
+	options->dump_dir[0] = 0;
+	options->is_compress_alg = FALSE;
+	options->compress_alg = MEMCR_COMPRESS_NONE;
+}
+
+static void init_pid_checkpoint_data(pid_t pid, struct service_options *options)
 {
 	pthread_mutex_lock(&checkpoint_service_data_lock);
 	for (int i=0; i<CHECKPOINTED_PIDS_LIMIT; ++i) {
@@ -835,6 +853,15 @@ static void init_pid_checkpoint_data(pid_t pid)
 			checkpoint_service_data[i].worker = PID_INVALID;
 			checkpoint_service_data[i].checkpoint_cmd_sd = SOCKET_INVALID;
 			checkpoint_service_data[i].state = STATE_RESTORED;
+			if (options) {
+				checkpoint_service_data[i].options.is_dump_dir = options->is_dump_dir;
+				strncpy(checkpoint_service_data[i].options.dump_dir, options->dump_dir,
+					MEMCR_DUMPDIR_LEN_MAX);
+				checkpoint_service_data[i].options.is_compress_alg = options->is_compress_alg;
+				checkpoint_service_data[i].options.compress_alg = options->compress_alg;
+			} else {
+				clear_checkpoint_options(&checkpoint_service_data[i].options);
+			}
 			pthread_mutex_unlock(&checkpoint_service_data_lock);
 			return;
 		}
@@ -851,11 +878,14 @@ static void cleanup_checkpointed_pids(void)
 		if (checkpoint_service_data[i].pid != PID_INVALID) {
 			fprintf(stdout, "[i] Killing PID %d\n", checkpoint_service_data[i].pid);
 			kill(checkpoint_service_data[i].pid, SIGKILL);
-			cleanup_pid(checkpoint_service_data[i].pid);
+			const char *dir = checkpoint_service_data[i].options.is_dump_dir ?
+				checkpoint_service_data[i].options.dump_dir : dfl_dump_dir;
+			cleanup_pid(checkpoint_service_data[i].pid, dir);
 			checkpoint_service_data[i].pid = PID_INVALID;
 			checkpoint_service_data[i].worker = PID_INVALID;
 			checkpoint_service_data[i].state = STATE_RESTORED;
 			checkpoint_service_data[i].checkpoint_cmd_sd = SOCKET_INVALID;
+			clear_checkpoint_options(&checkpoint_service_data[i].options);
 		}
 	}
 	pthread_mutex_unlock(&checkpoint_service_data_lock);
@@ -918,6 +948,7 @@ static void clear_pid_checkpoint_data(pid_t pid)
 			checkpoint_service_data[i].worker = PID_INVALID;
 			checkpoint_service_data[i].checkpoint_cmd_sd = SOCKET_INVALID;
 			checkpoint_service_data[i].state = STATE_RESTORED;
+			clear_checkpoint_options(&checkpoint_service_data[i].options);
 		}
 	}
 	pthread_mutex_unlock(&checkpoint_service_data_lock);
@@ -929,11 +960,14 @@ static void clear_pid_on_worker_exit_non_blocking(pid_t worker)
 		if (checkpoint_service_data[i].worker == worker) {
 			fprintf(stdout, "[+] Clearing pid: %d with worker: %d on worker exit ...\n",
 				checkpoint_service_data[i].pid, worker);
-			cleanup_pid(checkpoint_service_data[i].pid);
+			const char *dir = checkpoint_service_data[i].options.is_dump_dir ?
+				checkpoint_service_data[i].options.dump_dir : dfl_dump_dir;
+			cleanup_pid(checkpoint_service_data[i].pid, dir);
 			checkpoint_service_data[i].pid = PID_INVALID;
 			checkpoint_service_data[i].worker = PID_INVALID;
 			checkpoint_service_data[i].checkpoint_cmd_sd = SOCKET_INVALID;
 			checkpoint_service_data[i].state = STATE_RESTORED;
+			clear_checkpoint_options(&checkpoint_service_data[i].options);
 		}
 	}
 }
@@ -1629,7 +1663,7 @@ static int get_target_pages(int pid, struct vm_area vmas[], int nr_vmas)
 	if (pd < 0)
 		fprintf(stdout, "[i] /proc/pagemap open failed %m, using remote access\n");
 
-	snprintf(path, sizeof(path), "%s/pages-%d.img", dump_dir, pid);
+	snprintf(path, sizeof(path), "%s/pages-%d.img", dfl_dump_dir, pid);
 
 	fd = dump_open(path, O_CREAT | O_TRUNC | O_WRONLY, S_IRUSR | S_IWUSR);
 	if (fd < 0) {
@@ -1748,7 +1782,7 @@ static int target_set_pages(pid_t pid)
 	int cd = -1;
 	int fd = -1;
 
-	snprintf(path, sizeof(path), "%s/pages-%d.img", dump_dir, pid);
+	snprintf(path, sizeof(path), "%s/pages-%d.img", dfl_dump_dir, pid);
 
 	fd = dump_open(path, O_RDONLY, 0);
 	if (fd < 0) {
@@ -1870,7 +1904,7 @@ static int cmd_checkpoint(pid_t pid)
 	}
 
 	fprintf(stdout, "[i] download took %lu ms\n", diff_ms(&ts));
-	fprintf(stdout, "[i] stored at %s/pages-%d.img\n", dump_dir, pid);
+	fprintf(stdout, "[i] stored at %s/pages-%d.img\n", dfl_dump_dir, pid);
 
 	get_target_rss(pid, &vms_b);
 
@@ -2361,6 +2395,104 @@ static void sigpipe_handler(int sig, siginfo_t *sip, void *notused)
 	fprintf(stdout, "[!] program received SIGPIPE from %d.\n", sip->si_pid);
 }
 
+static void set_dump_dirs(const char *dirs)
+{
+	char real_dir[PATH_MAX];
+
+	//clear current allowed dirs
+	while (allowed_dump_dirs) {
+		if (allowed_dump_dirs->dir)
+			free(allowed_dump_dirs->dir);
+
+		struct dump_dir_list *curr = allowed_dump_dirs;
+		allowed_dump_dirs = allowed_dump_dirs->next;
+		free(curr);
+	}
+
+	if (dirs == NULL) {
+		fprintf(stderr, "[!] %s(): Error dump dir cannot be empty!\n", __func__);
+		exit(EXIT_FAILURE);
+	}
+
+	// Create a mutable copy of dirs
+	char *dirs_copy = strdup(dirs);
+	if (!dirs_copy) {
+		fprintf(stderr, "[!] %s(): Memory allocation error!\n", __func__);
+		exit(EXIT_FAILURE);
+	}
+
+	struct dump_dir_list *dump_dir_iter = NULL;
+	char *dir = strtok(dirs_copy, ";");
+	while (dir) {
+		if (realpath(dir, real_dir)) {
+			struct dump_dir_list *new_dump_dir = malloc(sizeof(struct dump_dir_list));
+			if (!new_dump_dir) {
+				fprintf(stderr, "[!] %s(): Memory allocation error!\n", __func__);
+				exit(EXIT_FAILURE);
+			}
+
+			new_dump_dir->dir = strdup(real_dir);
+			if (!new_dump_dir->dir) {
+				fprintf(stderr, "[!] %s(): Memory allocation error!\n", __func__);
+				exit(EXIT_FAILURE);
+			}
+			fprintf(stdout, "[+] Allowed dump directory: %s\n", new_dump_dir->dir);
+
+			new_dump_dir->next = NULL;
+
+			if (!allowed_dump_dirs) {
+				allowed_dump_dirs = new_dump_dir;
+				dump_dir_iter = allowed_dump_dirs;
+			} else {
+				dump_dir_iter->next = new_dump_dir;
+				dump_dir_iter = dump_dir_iter->next;
+			}
+
+		} else {
+			fprintf(stderr, "[!] %s(): Unable to resolve allowed directory: %s\n", __func__, dir);
+			exit(EXIT_FAILURE);
+		}
+
+		dir = strtok(NULL, ";");
+	}
+
+	free(dirs_copy);
+
+	if (!allowed_dump_dirs) {
+		fprintf(stderr, "[!] %s(): No allowed dump directories!\n", __func__);
+		exit(EXIT_FAILURE);
+	}
+
+	// Default dump dir is the first allowed one
+	dfl_dump_dir = allowed_dump_dirs->dir;
+	fprintf(stdout, "[+] %s(): Allowed dump directories set.\n", __func__);
+}
+
+
+static int is_dump_dir_path_allowed(const char *dump_dir_path) {
+	char real_dir_path[PATH_MAX];
+
+	// Resolve the real path
+	if (!realpath(dump_dir_path, real_dir_path)) {
+		fprintf(stderr, "[-] %s(): Unable to resolve dump dir path: %s\n", __func__, dump_dir_path);
+		return 0;
+	}
+
+	fprintf(stdout, "[+] %s(): Real dir path to check: %s\n", __func__, real_dir_path);
+
+	// iterate over allowed dump dirs and do an exact match
+	struct dump_dir_list *curr = allowed_dump_dirs;
+	while (curr) {
+		if (strcmp(real_dir_path, curr->dir) == 0) {
+			return 1;
+		}
+		curr = curr->next;
+	}
+
+	fprintf(stderr, "[-] %s(): Dump dir path is not allowed: %s\n", __func__, dump_dir_path);
+	return 0;
+}
+
 static int read_command(int cd, struct service_command *svc_cmd)
 {
 	int ret;
@@ -2374,6 +2506,124 @@ static int read_command(int cd, struct service_command *svc_cmd)
 	return ret;
 }
 
+static int read_command_v2(int cd, struct service_command *svc_cmd, struct service_options *options, size_t len)
+{
+	/* There must be at least service_command that can be followed by service_checkpoint_options */
+	if (len < sizeof(struct service_command)) {
+		fprintf(stderr, "[-] %s(): cmds len to short: %d\n", __func__, (unsigned int)len);
+		return -1;
+	}
+
+	int ret = read_command(cd, svc_cmd);
+	if (ret < 0) {
+		fprintf(stderr, "%s(): Error reading a command!\n", __func__);
+		return ret;
+	}
+
+	len -= sizeof(struct service_command);
+
+	switch (svc_cmd->cmd) {
+		case MEMCR_CHECKPOINT: {
+			fprintf(stdout, "[+] read MEMCR_CHECKPOINT for %d\n", svc_cmd->pid);
+			/* try to read checkpoint options */
+			memcr_svc_checkpoint_options option;
+			while (len >= sizeof(option) && _read(cd, &option, sizeof(option)) > 0 ) {
+				len -= sizeof(option);
+
+				switch (option)	{
+				case MEMCR_CHECKPOINT_DUMPDIR: {
+					/* read string till NULL */
+					unsigned int pos = 0;
+					while (len-- > 0 && (_read(cd, &options->dump_dir[pos], sizeof(char)) == sizeof(char)) &&
+						   (options->dump_dir[pos] != 0) && (++pos < MEMCR_DUMPDIR_LEN_MAX));
+
+					if (pos >= MEMCR_DUMPDIR_LEN_MAX || options->dump_dir[pos] != 0) {
+						fprintf(stderr, "[-] %s(): dump dir path too long or not terminated with NULL\n", __func__);
+						return -1;
+					}
+
+					if (is_dump_dir_path_allowed(options->dump_dir)) {
+						options->is_dump_dir = TRUE;
+						fprintf(stdout, "[+] read dump dir path for this checkpoint: %s\n", options->dump_dir);
+					} else {
+						fprintf(stderr, "[i] dump dir path incorrect, using default\n");
+					}
+					break;
+				}
+				case MEMCR_CHECKPOINT_COMPRESS_ALG:
+				{
+					if (len < sizeof(options->compress_alg) ||
+						_read(cd, &options->compress_alg, sizeof(options->compress_alg)) != sizeof(options->compress_alg)) {
+							fprintf(stderr, "[-] %s(): compression algorithm invalid\n", __func__);
+							return -1;
+					}
+
+					len -= sizeof(options->compress_alg);
+
+					if (options->compress_alg != MEMCR_COMPRESS_NONE
+					 && options->compress_alg != MEMCR_COMPRESS_LZ4
+					 && options->compress_alg != MEMCR_COMPRESS_ZSTD
+					) {
+						/* skip if not support */
+						fprintf(stderr, "[-] %s(): compression algorithm not supported: %d\n", __func__, options->compress_alg);
+						break;
+					}
+
+					options->is_compress_alg = TRUE;
+					const char *caToS[] = {
+						[MEMCR_COMPRESS_NONE] = "none",
+						[MEMCR_COMPRESS_LZ4] = "lz4",
+						[MEMCR_COMPRESS_ZSTD] = "zstd"};
+					fprintf(stdout, "[+] read compress alg for this checkpoint: %s\n", caToS[options->compress_alg]);
+					break;
+				}
+				default:
+					fprintf(stderr, "[-] %s(): checkpoint option invalid: %d\n", __func__, option);
+				}
+			}
+			break;
+		}
+		case MEMCR_RESTORE: {
+			/* nothing more to read for RESTORE*/
+			fprintf(stdout, "[+] read MEMCR_RESTORE for %d\n", svc_cmd->pid);
+			break;
+		}
+		default:
+			fprintf(stderr, "%s(): Error command not expected or invalid: %d!\n", __func__, svc_cmd->cmd);
+			return -1;
+	}
+
+	return 0;
+}
+
+static void set_checkpoint_options_dfl(pid_t pid)
+{
+	for (int i=0; i<CHECKPOINTED_PIDS_LIMIT; ++i) {
+		if (checkpoint_service_data[i].pid == pid) {
+			if (checkpoint_service_data[i].options.is_dump_dir)
+				dfl_dump_dir = checkpoint_service_data[i].options.dump_dir;
+
+			if (checkpoint_service_data[i].options.is_compress_alg)
+				switch (checkpoint_service_data[i].options.compress_alg) {
+					case MEMCR_COMPRESS_NONE:
+						fprintf(stdout, "[+] Default compress algorithm set to NONE.\n");
+						compress_init(NULL, MAX_VM_REGION_SIZE);   
+						break;
+					case MEMCR_COMPRESS_LZ4:
+						fprintf(stdout, "[+] Default compress algorithm set to LZ4.\n");
+						compress_init("lz4", MAX_VM_REGION_SIZE); 
+						break;
+					case MEMCR_COMPRESS_ZSTD:
+						fprintf(stdout, "[+] Default compress algorithm set to ZSTD.\n");
+						compress_init("zstd", MAX_VM_REGION_SIZE);
+						break;
+				}
+
+			return;
+		}
+	}
+}
+
 static int send_response_to_client(int cd, memcr_svc_response resp_code)
 {
 	struct service_response svc_resp = { .resp_code = resp_code };
@@ -2505,7 +2755,7 @@ out:
 	if (ret) {
 		fprintf(stderr, "[%d] %s() Checkpoint failed! Killing the target PID %d...\n", getpid(), __func__, pid);
 		kill(pid, SIGKILL);
-		cleanup_pid(pid);
+		cleanup_pid(pid, dfl_dump_dir);
 		return ret;
 	}
 
@@ -2536,7 +2786,7 @@ out:
 		kill(post_checkpoint_cmd.pid, SIGKILL);
 	}
 	unseize_target();
-	cleanup_pid(post_checkpoint_cmd.pid);
+	cleanup_pid(post_checkpoint_cmd.pid, dfl_dump_dir);
 
 	return ret;
 }
@@ -2552,6 +2802,7 @@ static int application_worker(pid_t pid, int checkpoint_resp_socket)
 		ret |= rsd;
 
 	register_socket_for_checkpoint_service_cmds(checkpoint_resp_socket);
+	set_checkpoint_options_dfl(pid);
 
 	if (0 == ret) {
 		ret |= checkpoint_worker(pid);
@@ -2637,7 +2888,7 @@ static int checkpoint_procedure_service(int checkpointSocket, int cd, int pid, i
 		// unable to read response from worker, kill both
 		kill(pid, SIGKILL);
 		kill(worker_pid, SIGKILL);
-		cleanup_pid(pid);
+		cleanup_pid(pid, dfl_dump_dir);
 		send_response_to_client(cd, MEMCR_ERROR_GENERAL);
 		return MEMCR_ERROR_GENERAL;
 	}
@@ -2677,7 +2928,7 @@ static void restore_procedure_service(int cd, struct service_command svc_cmd, in
 		// unable to read response from worker, kill both
 		kill(svc_cmd.pid, SIGKILL);
 		kill(worker_pid, SIGKILL);
-		cleanup_pid(svc_cmd.pid);
+		cleanup_pid(svc_cmd.pid, dfl_dump_dir);
 		ret = -1;
 	}
 
@@ -2781,7 +3032,7 @@ retry:
 	goto retry;
 }
 
-static void service_command(struct service_command_ctx *svc_ctx)
+static void service_command(struct service_command_ctx *svc_ctx, struct service_options *checkpoint_options)
 {
 	int ret = MEMCR_OK;
 	switch (svc_ctx->svc_cmd.cmd)
@@ -2798,7 +3049,7 @@ static void service_command(struct service_command_ctx *svc_ctx)
 			break;
 		}
 
-		init_pid_checkpoint_data(svc_ctx->svc_cmd.pid);
+		init_pid_checkpoint_data(svc_ctx->svc_cmd.pid, checkpoint_options);
 		ret = service_cmds_push_back(svc_ctx);
 		if (!ret)
 			fprintf(stdout, "[+] Checkpoint request scheduled...\n");
@@ -2851,6 +3102,7 @@ static int service_mode(const char *listen_location, const int gid)
 	struct timeval tv;
 	int errsv;
 	pthread_t svc_cmd_thread_id;
+	struct service_options checkpoint_options;
 
 	if (listen_port > 0)
 		csd = setup_listen_tcp_socket(listen_port);
@@ -2891,6 +3143,13 @@ static int service_mode(const char *listen_location, const int gid)
 		cd = accept(csd, NULL, NULL);
 		if (cd >= 0) {
 			struct service_command_ctx svc_ctx = { .cd = cd };
+			// set rcv timeout for the socket
+			struct timeval rcv_timeout = {
+				.tv_sec = SERVICE_MODE_SOCKET_TIMEOUT_MS/1000,
+				.tv_usec = (SERVICE_MODE_SELECT_TIMEOUT_MS%1000)*1000
+			};
+			setsockopt(cd, SOL_SOCKET, SO_RCVTIMEO, &rcv_timeout, sizeof(rcv_timeout));
+
 			ret = read_command(cd, &svc_ctx.svc_cmd);
 			if (ret < 0) {
 				fprintf(stderr, "%s(): Error reading a command!\n", __func__);
@@ -2898,7 +3157,19 @@ static int service_mode(const char *listen_location, const int gid)
 				continue;
 			}
 
-			service_command(&svc_ctx);
+			clear_checkpoint_options(&checkpoint_options);
+
+			if (svc_ctx.svc_cmd.cmd == MEMCR_CMDS_V2) {
+				size_t cmds_len = svc_ctx.svc_cmd.pid;
+				ret = read_command_v2(cd, &svc_ctx.svc_cmd, &checkpoint_options, cmds_len);
+				if (ret < 0) {
+					fprintf(stderr, "%s(): Error reading a command!\n", __func__);
+					close(cd);
+					continue;
+				}
+			}
+
+			service_command(&svc_ctx, &checkpoint_options);
 			continue;
 		}
 
@@ -2968,7 +3239,7 @@ out:
 	}
 
 	unseize_target();
-	cleanup_pid(pid);
+	cleanup_pid(pid, dfl_dump_dir);
 
 	return ret;
 }
@@ -2993,7 +3264,7 @@ static void usage(const char *name, int status)
 		"options:\n" \
 		"  -h --help		help\n" \
 		"  -p --pid		target process pid\n" \
-		"  -d --dir		dir where memory dump is stored (defaults to /tmp)\n" \
+		"  -d --dir		dir/dirs where memory dump can be stored (defaults to /tmp. Separated by ';')\n" \
 		"  -S --parasite-socket-dir	dir where socket to communicate with parasite is created\n" \
 		"        (abstract socket will be used if no path specified)\n" \
 		"  -G --parasite-socket-gid	group ID for parasite UNIX domain socket file, valid only for if --parasite-socket-dir provided\n" \
@@ -3059,7 +3330,7 @@ int main(int argc, char *argv[])
 		{ NULL,				0,	NULL,	0  }
 	};
 
-	dump_dir = "/tmp";
+	set_dump_dirs(MEMCR_DUMPDIR_DEFAULT);
 	parasite_socket_dir = NULL;
 	parasite_socket_use_netns = 0;
 
@@ -3072,7 +3343,7 @@ int main(int argc, char *argv[])
 				pid = atoi(optarg);
 				break;
 			case 'd':
-				dump_dir = optarg;
+				set_dump_dirs(optarg);
 				break;
 			case 'S':
 				parasite_socket_dir = optarg;
diff --git a/memcrclient_proto.h b/memcrclient_proto.h
index f9dee66..8641834 100644
--- a/memcrclient_proto.h
+++ b/memcrclient_proto.h
@@ -21,9 +21,23 @@
 
 typedef enum {
   MEMCR_CHECKPOINT = 100,
-  MEMCR_RESTORE
+  MEMCR_RESTORE,
+	MEMCR_CMDS_V2
 } memcr_svc_cmd;
 
+typedef enum {
+	MEMCR_CHECKPOINT_DUMPDIR = 200,
+	MEMCR_CHECKPOINT_COMPRESS_ALG,
+} memcr_svc_checkpoint_options;
+
+#define MEMCR_DUMPDIR_LEN_MAX	1024
+
+typedef enum {
+	MEMCR_COMPRESS_NONE = 0,
+	MEMCR_COMPRESS_LZ4,
+	MEMCR_COMPRESS_ZSTD
+} memcr_compress_alg;
+
 struct service_command {
   memcr_svc_cmd cmd;
   pid_t pid;
@@ -39,4 +53,11 @@ struct service_response {
   memcr_svc_response resp_code;
 } __attribute__((packed));
 
+struct service_options {
+	int is_dump_dir;
+	char dump_dir[MEMCR_DUMPDIR_LEN_MAX];
+	int is_compress_alg;
+	memcr_compress_alg compress_alg;
+};
+
 #endif /* __MEMCR_CLIENT_PROTO_H__ */
-- 
2.43.0

